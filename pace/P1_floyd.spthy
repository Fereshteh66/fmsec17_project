/*
Protocoll P1 implemented by Floyd

V1: Simply send the nonce back and forth as well as some sanity checks.
V2: Add secrecy lemmas.
V3: Add checks for unidirectional, injective agreement on the nounce. Based directly on the lecture slides and Tamarin manual.
*/

theory P1
begin

builtins: symmetric-encryption

/* We want to formalize the following protocoll:
	R -> S : n
	S -> R : {n}_k(R,S)
*/

// Establish a shared key for two DIFFERENT parties O and P
rule Establish_SharedKey:
  [ Fr(~kAB) ]
--[ Restrict_NEQ($A, $B)
  , Secret(~kAB)
  ]->
  [ !SharedKey($A, $B, ~kAB) ]

// The adversary can reveal the shared key of victims V and W
// Here it should suffice to simply imply that either of the key has been compromised.
rule Reveal:
  [ !SharedKey(V, W, kVW) ]
--[ Reveal(kVW) ]->
  [ Out(kVW) ]

// Watch out: !SharedKey(A,B,kAB) <> !SharedKey(B,A,kBA)

// This is a very verbose formulation, in which states aren't collapsed
// Initialize R
rule Init_R:
  [ Fr(~id), !SharedKey(R, S, kRS) ]
--[ Initialized(R, ~id) ]->
  [ St_R_0(R, ~id, S, kRS) ]

// Initialize S
rule Init_S:
  [ Fr(~id), !SharedKey(R, S, kRS) ]
--[ Initialized(S, ~id) ]->
  [ St_S_0(S, ~id, R, kRS) ]

// First message sent by R
rule R_1_send:
  let m = ~x
  in
  [ St_R_0(R, id, S, kRS) 
  , Fr(~x) // the nonce
  ]
--[ Send(R, m) ]->
  [ St_R_1(R, id, S, kRS, ~x)
  , Out(m)
  ]

// First message received by S
rule S_1_receive:
  [ St_S_0(S, id, R, kRS)
  , In(m) // the message, supposedly the nonce from R
  ]
--[ Recv(S, m) ]->
  [ St_S_1(S, id, R, kRS, m) ]

// Message sent back by S
rule S_2_send:
  let m = senc(x, kRS)
  in
  [ St_S_1(S, id, R, kRS, x) ]
--[ Send(S,m)
  , Running(S, R, x) ]->
  [ Out(m)] // no further state of S needed at this point

// Sent back message received by R
rule R_2_receive:
  let m = senc(x, kRS)
  in
  [ St_R_1(R, id, S, kRS, x)
  , In(m)
  ]
--[ Recv(R, m)
  , Commit(R, S, x) ]->
  []

restriction NEQ:
  " All x y #i. Restrict_NEQ(x, y) @i ==> not( x = y ) "


// Simplistic Executability test
lemma executable: exists-trace
  " Ex P Q m #i #j. Send(P, m) @i & Recv(Q, m) @j "

// Check wether the intruder can act as a participant
lemma intruder_participation: exists-trace
  " Ex Q m #j. not(Ex P #i. Send(P, m) @i) & Recv(Q, m) @j "

// secrecy of all keys except if they are revealed
lemma key_secrecy: all-traces
  " All key #i. Secret(key) @i
==> not( Ex #j. K(key) @j ) | ( Ex #k. Reveal(key) @k)
  "

// injective agreement on a term
lemma injective_agreement: all-traces
  " All P O t #i. Commit(P, O, t) @i
==> ( Ex #j. Running(O, P, t) @j
    & j < i
    & not( Ex Palt Oalt #ialt. Commit(Palt, Oalt, t) @ialt & not(#ialt = #i) )
    )
  | ( Ex k #r. Reveal(k) @r )
  "

end
