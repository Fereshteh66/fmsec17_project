/*
Protocoll P1 implemented by Floyd

V1: Simply send the nonce back and forth as well as some sanity checks.
V2: Add secrecy lemmas.
V3: Add checks for unidirectional, injective agreement on the nounce. Based directly on the lecture slides and Tamarin manual.
V4: Adapt to recommendations and clearly distinguish between role and name.
*/

/* We want to formalize the following protocoll:
	R -> S : <1, na>
	S -> R : { <2, nb> }_k(R,S)
*/

theory P1
begin

builtins: symmetric-encryption

// Establish a shared key for two DIFFERENT parties O and P
rule Establish_SharedKey:
  [ Fr(~kAB) ]
--[ Restrict_NEQ($A, $B)
  , Secret($A, ~kAB), Honest($A) // A holds the secret kAB
  , Secret($B, ~kAB), Honest($B) // B holds the secret kAB
  ]->
  [ !SharedKey($A, $B, ~kAB) ]

// The adversary can reveal the shared key of victims V and W
// Here it should suffice to simply imply that either of the key has been compromised.
rule Reveal:
  [ !SharedKey(V, W, kVW) ]
--[ Reveal(V), Reveal(W) ]->
  [ Out(kVW) ]

// Watch out: !SharedKey(A,B,kAB) <> !SharedKey(B,A,kBA)

/*
  Initialization
*/
// Initialize R
rule Init_R:
  [ Fr(~id), !SharedKey(A, B, kAB) ]
--[ Create(A, ~id, 'R') ]->
  [ St_R_0(A, ~id, B, kAB) ]

// Initialize S
rule Init_S:
  [ Fr(~id), !SharedKey(A, B, kAB) ]
--[ Create(B, ~id, 'S') ]->
  [ St_S_0(B, ~id, A, kAB) ]

/*
  Protocol
*/

/* R -> S : <1, na> */

// First message sent by R
rule R_1_send:
  let m = <'1', ~na>
  in
  [ St_R_0(A, id, B, kAB) 
  , Fr(~na) // the nonce
  ]
--[ Send(A, m)
  , Start()
  ]->
  [ St_R_1(A, id, B, kAB, ~na)
  , Out(m)
  ]

// First message received by S
rule S_1_receive:
  let m = <'1', na>
  in
  [ St_S_0(B, id, A, kAB)
  , In(m) // the message, supposedly the nonce from R
  ]
--[ Recv(B, m) ]->
  [ St_S_1(B, id, A, kAB, na) ]

/* S -> R : { <2, nb> }_k(R,S) */

// Message sent back by S
rule S_2_send:
  let m = <'2', senc(na, kAB)>
  in
  [ St_S_1(B, id, A, kAB, na) ]
--[ Send(B,m)
  , Running(B, A, <'I', 'R', na>) 
  ]->
  [ St_S_2(B, id, A, kAB, na)
  , Out(m)
  ] 

// Sent back message received by R
rule R_2_receive:
  let m = <'2', senc(na, kAB)>
  in
  [ St_R_1(A, id, B, kAB, na)
  , In(m)
  ]
--[ Recv(A, m)
  , Commit(A, B, <'I', 'R', na>), Honest(A), Honest(B) // A and B are required to be honest at this moment
  , End()
  ]->
  [ St_R_2(A, id, B, kAB, na) ]

/*
  Restrictions
*/
restriction NEQ:
  " All x y #i. Restrict_NEQ(x, y) @i ==> not( x = y ) "


// Simplistic Executability test
lemma executable: exists-trace
  " Ex #i #j. Start() @i & End() @j "

// Check wether the intruder can act as a participant
lemma intruder_participation: exists-trace
  " Ex Q m #j. not(Ex P #i. Send(P, m) @i) & Recv(Q, m) @j "

lemma secrecy:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

/*
lemma secrecy_PFS:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i & r < i)"
*/

lemma noninjectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma injectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j 
        & j < i
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>) @i2
                           & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

/*
lemma noninjectiveagreementRESPONDER:
  "All a b t #i. 
    Commit(a,b,<'R','I',t>) @i
    ==> (Ex #j. Running(b,a,<'R','I',t>) @j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"

lemma injectiveagreementRESPONDER:
  "All a b t #i. 
    Commit(a,b,<'R','I',t>) @i
    ==> (Ex #j. Running(b,a,<'R','I',t>) @j 
              & j < i
              & not (Ex a2 b2 #i2. Commit(a2,b2,<'R','I',t>) @i2
                                 & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"
*/


end
