theory OTR1
begin



/*
  We want to formalize the following protocol
	
    1. A -> B: {g^x}sk(A), pk(A)
    2. B -> A: {g^y}sk(B), pk(B)
*/

builtins: 
  diffie-hellman, signing



// Public key infrastructure

rule Register:
 [ Fr(~sk) ]  
 --[ KeySetup($A) ]->  
 [ !Ltk($A, ~sk), !Pk($A, pk(~sk)), Out(pk(~sk)) ]

rule Reveal:
 [ !Ltk(A, ltk) ]  --[ Reveal(A) ]->   [ Out(ltk) ]


// Initialize A
rule Init_I:
 [ Fr(~id) , !Ltk($A, skA)  , !Pk($B, pkB) ]
 --[ Create_I($A, ~id) ]->
 [ St_A_1($A, ~id, $B, skA, pkB) ]


// Initialize B
rule Init_R:
 [ Fr(~id) , !Ltk(B, skB) , !Pk(A, pkA) ]
 --[ Create_R(B, ~id) ]->
 [ St_B_1(B, ~id, A, skB, pkA) ]


// 1. A send
rule A_1_Send:

 let M = <sign{'1', 'g' ^ ~x}skA, pk(skA)>
 in

 [ St_A_1(A, id, B, skA, pkB) , Fr(~x) ] 
 --[ Send(A, M )]->
 [ St_A_2(A, id, B, skA, pkB, ~x) , Out( M ) ]


// 1. B receive
rule B_1_Recv:

 let M = <sign{'1', X}skA, pkA>
 in

 [ St_B_1(B, id, A, skB, pk(skA)), In( M ) ]
 --[ Recv( A, M ) ]->
 [ St_B_2(B, id, A, skB, pk(skA), X) ]


// 2. B send
rule B_2_Send:

 let M = <sign{'2','g' ^ ~y}skB, pk(skB)>
 in
 [ St_B_2(B, id, A, skB, pk(skA), X) , Fr(~y) ]
 --[ Send(B, M ) , Secret(B, X ^ ~y), Honest(B), Honest(A) ]->
 [ St_B_3(B, id, A, skB, pk(skA), X, ~y) , Out( M ) ]


// 2. A receive
rule A_2_Recv:

 let M = <sign{'2',Y}skB, pkB>
 in
 [ St_A_2(A, id, B, skA, pk(skB), x) , In( M ) ]
 --[ Recv( A, M ), Finish(), Secret(A, Y ^ x) , Honest(A), Honest(B) ]->
 [ St_A_3(A, id, B, skA, pk(skB), x)]





// Security properties

lemma executable:
  exists-trace
    "Ex #i. Finish() @i & not (Ex A #j. Reveal(A)@j)
    & (All X Y id1 id2 #i #j. Create_I(X, id1)@i & Create_I(Y, id2)@j ==> X = Y & id1 = id2 & #i = #j)
    & (All X Y id1 id2 #i #j. Create_R(X, id1)@i & Create_R(Y, id2)@j ==> X = Y & id1 = id2 & #i = #j)"


lemma secrecy:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i)"


lemma secrecy_PFS:
  "All A x #i. 
    Secret(A,x) @i ==> 
    not (Ex #j. K(x)@j)
        | (Ex X #r. Reveal(X)@r & Honest(X) @i & r < i)"

restriction onlyonekeysetup:
  " All X Y #i #j. KeySetup(X, Y)@i & KeySetup(X, Y)@j ==> #i = #j"

end
