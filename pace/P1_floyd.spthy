/*
Protocoll P1 implemented by Floyd

V1: Simply send the nonce back and forth as well as some sanity checks.
V2: Add secrecy lemmas.
V3: Add checks for unidirectional, injective agreement on the nounce. Based directly on the lecture slides and Tamarin manual.
*/

theory P1
begin

builtins: symmetric-encryption

/* We want to formalize the following protocoll:
	A -> B : x
	B -> A : {x}_k(A,B)
*/

// Establish a shared key for two DIFFERENT parties O and P
rule Establish_SharedKey:
  [ Fr(~kPQ) ]
--[ Restrict_NEQ($P, $Q)
  , Secret(~kPQ)
  ]->
  [ !SharedKey($P, $Q, ~kPQ) ]

// The adversary can reveal the shared key of victims V and W
// Here it should suffice to simply imply that either of the key has been compromised.
rule Reveal:
  [ !SharedKey(V, W, kVW) ]
--[ Reveal(kVW) ]->
  [ Out(kVW) ]

// Watch out: !SharedKey(A,B,kAB) <> !SharedKey(B,A,kBA)

// This is a very verbose formulation, in which states aren't collapsed
// Initialize A
rule Init_A:
  [ Fr(~id), !SharedKey(A, B, kAB) ]
--[ Initialized(A, ~id) ]->
  [ St_A_0(A, ~id, B, kAB) ]

// Initialize B
rule Init_B:
  [ Fr(~id), !SharedKey(A, B, kAB) ]
--[ Initialized(B, ~id) ]->
  [ St_B_0(B, ~id, A, kAB) ]

// First message sent by A
rule A_1_send:
  let m = ~x
  in
  [ St_A_0(A, id, B, kAB) 
  , Fr(~x) // the nonce
  ]
--[ Send(A, m) ]->
  [ St_A_1(A, id, B, kAB, ~x)
  , Out(m)
  ]

// First message received by B
rule B_1_receive:
  [ St_B_0(B, id, A, kAB)
  , In(m) // the message, supposedly the nonce from A
  ]
--[ Recv(B, m) ]->
  [ St_B_1(B, id, A, kAB, m) ]

// Message sent back by B
rule B_2_send:
  let m = senc(x, kAB)
  in
  [ St_B_1(B, id, A, kAB, x) ]
--[ Send(B,m)
  , Running(B, A, x) ]->
  [ Out(m)] // no further state of B needed at this point

// Sent back message received by A
rule A_2_receive:
  let m = senc(x, kAB)
  in
  [ St_A_1(A, id, B, kAB, x)
  , In(m)
  ]
--[ Recv(A, m)
  , Commit(A, B, x) ]->
  []

restriction NEQ:
  " All x y #i. Restrict_NEQ(x, y) @i ==> not( x = y ) "


// Simplistic Executability test
lemma executable: exists-trace
  " Ex P Q m #i #j. Send(P, m) @i & Recv(Q, m) @j "

// Check wether the intruder can act as a participant
lemma intruder_participation: exists-trace
  " Ex Q m #j. not(Ex P #i. Send(P, m) @i) & Recv(Q, m) @j "

// secrecy of all keys except if they are revealed
lemma key_secrecy: all-traces
  " All key #i. Secret(key) @i
==> not( Ex #j. K(key) @j ) | ( Ex #k. Reveal(key) @k)
  "

// injective agreement on a term
lemma injective_agreement: all-traces
  " All P O t #i. Commit(P, O, t) @i
==> ( Ex #j. Running(O, P, t) @j
    & j < i
    & not( Ex Palt Oalt #ialt. Commit(Palt, Oalt, t) @ialt & not(#ialt = #i) )
    )
  | ( Ex k #r. Reveal(k) @r )
  "

end
